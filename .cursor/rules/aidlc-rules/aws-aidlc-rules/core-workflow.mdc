---
alwaysApply: true
---

# ðŸš¨ CRITICAL: REQUEST TYPE CLASSIFICATION

**BEFORE responding to ANY user message, CLASSIFY the request type:**

## Request Classification Matrix

| Type | Description | Action Required |
|------|-------------|-----------------|
| **â“ QUESTION** | Asking about AIDLC, how things work, explanations | âœ… Answer directly - NO workflow needed |
| **ðŸ“‹ WORK REQUEST** | Add, modify, fix, enhance, create, implement, update | ðŸ”„ **MUST follow AIDLC workflow** |
| **ðŸ“Š STATUS CHECK** | Check status, what's next, current state | âœ… Check state file and respond |

## Examples

### â“ Questions (Answer Directly)
- "What is AIDLC?" â†’ Answer directly
- "How do I research external information?" â†’ Answer directly
- "What does Workspace Detection do?" â†’ Answer directly
- "Explain NFR Requirements" â†’ Answer directly
- "How does the audit system work?" â†’ Answer directly

### ðŸ“‹ Work Requests (MUST Follow AIDLC)
- "Add feature X" â†’ **AIDLC Workflow**
- "Fix bug in Y" â†’ **AIDLC Workflow**
- "Create API for Z" â†’ **AIDLC Workflow**
- "Update readme" â†’ **AIDLC Workflow**
- "Add diagram" â†’ **AIDLC Workflow**
- "Refactor code" â†’ **AIDLC Workflow**
- "Optimize performance" â†’ **AIDLC Workflow**
- "Implement authentication" â†’ **AIDLC Workflow**
- "Modify the config file" â†’ **AIDLC Workflow**
- "Delete unused code" â†’ **AIDLC Workflow**

### ðŸ“Š Status Checks (Check State)
- "/aidlc-status" â†’ Read branch state file (`state/{branch}.md`) and report
- "What stage are we on?" â†’ Read branch state file and report
- "What's next?" â†’ Read branch state file and report

### ðŸ”§ Fix/Resume (Post-Completion Errors)
- "Fix error: [message]" â†’ **Fix/Resume Flow** (skip inception stages)
- "à¸žà¸š error: [message]" â†’ **Fix/Resume Flow**
- "Build failed" â†’ **Fix/Resume Flow**
- "Test failed" â†’ **Fix/Resume Flow**

---

## ðŸ‘‹ First-Time Welcome Message

**Display ONCE at the start of any NEW AI-DLC workflow (not for resuming sessions):**

> **Welcome to AI-DLC (AI-Driven Development Life Cycle)!**
>
> I'll guide you through an adaptive software development workflow that intelligently tailors itself to your specific needs.
>
> **What is AI-DLC?**
> AI-DLC is a structured yet flexible process that adapts to your project's needs:
> - **Analyzes your requirements** and asks clarifying questions when needed
> - **Plans the optimal approach** based on complexity and risk
> - **Skips unnecessary steps** for simple changes while providing comprehensive coverage for complex projects
> - **Documents everything** so you have a complete record of decisions and rationale
>
> **The Three-Phase Lifecycle:**
> - ðŸ”µ **INCEPTION** - Planning & Architecture (WHAT and WHY)
> - ðŸŸ¢ **CONSTRUCTION** - Design, Implementation & Test (HOW)
> - ðŸŸ¡ **OPERATIONS** - Deployment & Monitoring (future)
>
> **Key Principles:**
> - âš¡ **Fully Adaptive**: Each stage independently evaluated
> - ðŸŽ¯ **Efficient**: Simple changes execute only essential stages
> - ðŸ“‹ **Comprehensive**: Complex changes get full treatment
> - ðŸ” **Transparent**: You see and approve the execution plan
> - ðŸ“ **Documented**: Complete audit trail of all decisions
> - ðŸŽ›ï¸ **User Control**: You can request stages be included or excluded
>
> Let's begin!

---

## ðŸ”„ FIX/RESUME FLOW (Post-Completion Errors)

**Use this flow when:**
1. AIDLC workflow is COMPLETE on current branch
2. User reports an error (build failure, test failure, runtime error)
3. Fix is within the same feature scope

**Detection Criteria:**
- Branch state file shows `Current Stage: âœ… COMPLETE`
- User message contains error-related keywords (fix, error, bug, failed, broken, crash)
- Context is within existing feature (not new functionality)

**Flow Execution:**

1. **Log in Audit**: Record the error report with full details
2. **Quick Analysis**: Identify affected code (no new artifacts needed)
3. **Direct to Code Generation**: Skip all inception/design stages
4. **Fix Code**: Apply targeted fix
5. **Update Tests**: Add/modify tests if needed
6. **Update CHANGELOG**: Add fix entry
7. **Update State**: Increment fix cycle counter

**State Tracking for Fixes:**
```markdown
## Fix Cycles
- Fix #1: [timestamp] - [brief description]
- Fix #2: [timestamp] - [brief description]
```

**Artifacts (Minimal):**
- No new inception documents
- No new design documents
- Only: audit log entry + CHANGELOG update + code changes

**Example Flow:**
```
User: "Fix null pointer in UserService.getUser()"

AI:
1. âœ… Log in audit/main.md
2. âœ… Analyze: NullPointerException in UserService line 45
3. âœ… Skip inception stages (workflow complete)
4. âœ… Apply fix: Add null check
5. âœ… Update test: Add testGetUserNotFound()
6. âœ… Update CHANGELOG
7. âœ… Update state: Fix #1 logged
```

---

## ðŸ”’ MANDATORY WORKFLOW ENFORCEMENT

**For ALL work requests, you MUST:**

1. **FIRST**: Log the user's request in branch audit file (`audit/{branch}.md`)
2. **THEN**: Execute Workspace Detection (check branch state file `state/{branch}.md`)
3. **THEN**: Follow appropriate AIDLC stages based on project state

**âŒ FORBIDDEN**: Making code changes or file modifications without following AIDLC workflow

**âš ï¸ NEVER skip these steps, even for "simple" requests**

---

## Workspace Detection (ALWAYS EXECUTE)

1. **MANDATORY**: Log initial user request in branch audit file with complete raw input
2. Load all steps from `inception/workspace-detection.md`
3. Execute workspace detection:
   - Check for existing branch state file `state/{branch}.md` (resume if found)
   - Scan workspace for existing code
   - Determine if brownfield or greenfield
   - Check for existing reverse engineering artifacts
4. Determine next phase: Reverse Engineering (if brownfield and no artifacts) OR Requirements Analysis
5. **MANDATORY**: Log findings in branch audit file
6. Present completion message to user (see workspace-detection.md for message formats)
7. Automatically proceed to next phase

## Reverse Engineering (CONDITIONAL - Brownfield Only)

**Execute IF**:
- Existing codebase detected
- No previous reverse engineering artifacts found

**Skip IF**:
- Greenfield project
- Previous reverse engineering artifacts exist

**Execution**:
1. **MANDATORY**: Log start of reverse engineering in branch audit file
2. Load all steps from `inception/reverse-engineering.md`
3. Execute reverse engineering:
   - Analyze all packages and components
   - Generate a busienss overview of the whole system covering the business transactions
   - Generate architecture documentation
   - Generate code structure documentation
   - Generate API documentation
   - Generate component inventory
   - Generate Interaction Diagrams depicting how business transactions are implemented across components
   - Generate technology stack documentation
   - Generate dependencies documentation

4. **Wait for Explicit Approval**: Present detailed completion message (see reverse-engineering.md for message format) - DO NOT PROCEED until user confirms
5. **MANDATORY**: Log user's response in branch audit file with complete raw input

## Requirements Analysis (ALWAYS EXECUTE - Adaptive Depth)

**Always executes** but depth varies based on request clarity and complexity:
- **Minimal**: Simple, clear request - just document intent analysis
- **Standard**: Normal complexity - gather functional and non-functional requirements
- **Comprehensive**: Complex, high-risk - detailed requirements with traceability

**Execution**:
1. **MANDATORY**: Log any user input during this phase in branch audit file
2. Load all steps from `inception/requirements-analysis.md`
3. Execute requirements analysis:
   - Load reverse engineering artifacts (if brownfield)
   - Analyze user request (intent analysis)
   - Determine requirements depth needed
   - Assess current requirements
   - Ask clarifying questions (if needed)
   - Generate requirements document
4. Execute at appropriate depth (minimal/standard/comprehensive)
5. **Wait for Explicit Approval**: Follow approval format from requirements-analysis.md detailed steps - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

## User Stories (CONDITIONAL)

**INTELLIGENT ASSESSMENT**: Use multi-factor analysis to determine if user stories add value:

**ALWAYS Execute IF** (High Priority Indicators):
- New user-facing features or functionality
- Changes affecting user workflows or interactions
- Multiple user types or personas involved
- Complex business requirements with acceptance criteria needs
- Cross-functional team collaboration required
- Customer-facing API or service changes
- New product capabilities or enhancements

**LIKELY Execute IF** (Medium Priority - Assess Complexity):
- Modifications to existing user-facing features
- Backend changes that indirectly affect user experience
- Integration work that impacts user workflows
- Performance improvements with user-visible benefits
- Security enhancements affecting user interactions
- Data model changes affecting user data or reports

**COMPLEXITY-BASED ASSESSMENT**: For medium priority cases, execute user stories if:
- Request involves multiple components or services
- Changes span multiple user touchpoints
- Business logic is complex or has multiple scenarios
- Requirements have ambiguity that stories could clarify
- Implementation affects multiple user journeys
- Change has significant business impact or risk

**SKIP ONLY IF** (Low Priority - Simple Cases):
- Pure internal refactoring with zero user impact
- Simple bug fixes with clear, isolated scope
- Infrastructure changes with no user-facing effects
- Technical debt cleanup with no functional changes
- Developer tooling or build process improvements
- Documentation-only updates

**ASSESSMENT CRITERIA**: When in doubt, favor inclusion of user stories for:
- Requests with business stakeholder involvement
- Changes requiring user acceptance testing
- Features with multiple implementation approaches
- Work that benefits from shared team understanding
- Projects where requirements clarity is valuable

**ASSESSMENT PROCESS**: 
1. Analyze request complexity and scope
2. Identify user impact (direct or indirect)
3. Evaluate business context and stakeholder needs
4. Consider team collaboration benefits
5. Default to inclusion for borderline cases

**Note**: If Requirements Analysis executed, Stories can reference and build upon those requirements.

**User Stories has two parts within one stage**:
1. **Part 1 - Planning**: Create story plan with questions, collect answers, analyze for ambiguities, get approval
2. **Part 2 - Generation**: Execute approved plan to generate stories and personas

**Execution**:
1. **MANDATORY**: Log any user input during this phase in branch audit file
2. Load all steps from `inception/user-stories.md`
3. **MANDATORY**: Perform intelligent assessment (Step 1 in user-stories.md) to validate user stories are needed
4. Load reverse engineering artifacts (if brownfield)
5. If Requirements exist, reference them when creating stories
6. Execute at appropriate depth (minimal/standard/comprehensive)
7. **PART 1 - Planning**: Create story plan with questions, wait for user answers, analyze for ambiguities, get approval
8. **PART 2 - Generation**: Execute approved plan to generate stories and personas
9. **Wait for Explicit Approval**: Follow approval format from user-stories.md detailed steps - DO NOT PROCEED until user confirms
10. **MANDATORY**: Log user's response in branch audit file with complete raw input

## Workflow Planning (ALWAYS EXECUTE)

1. **MANDATORY**: Log any user input during this phase in branch audit file
2. Load all steps from `inception/workflow-planning.md`
3. **MANDATORY**: Load content validation rules from `common/content-validation.md`
4. Load all prior context:
   - Reverse engineering artifacts (if brownfield)
   - Intent analysis
   - Requirements (if executed)
   - User stories (if executed)
5. Execute workflow planning:
   - Determine which phases to execute
   - Determine depth level for each phase
   - Create multi-package change sequence (if brownfield)
   - Generate workflow visualization (VALIDATE Mermaid syntax before writing)
6. **MANDATORY**: Validate all content before file creation per content-validation.md rules
7. **Wait for Explicit Approval**: Present recommendations using language from workflow-planning.md Step 9, emphasizing user control to override recommendations - DO NOT PROCEED until user confirms
8. **MANDATORY**: Log user's response in branch audit file with complete raw input

## Application Design (CONDITIONAL)

**Execute IF**:
- New components or services needed
- Component methods and business rules need definition
- Service layer design required
- Component dependencies need clarification

**Skip IF**:
- Changes within existing component boundaries
- No new components or methods
- Pure implementation changes

**Execution**:
1. **MANDATORY**: Log any user input during this phase in branch audit file
2. Load all steps from `inception/application-design.md`
3. Load reverse engineering artifacts (if brownfield)
4. Execute at appropriate depth (minimal/standard/comprehensive)
5. **Wait for Explicit Approval**: Present detailed completion message (see application-design.md for message format) - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

## Units Generation (CONDITIONAL)

**Execute IF**:
- System needs decomposition into multiple units of work
- Multiple services or modules required
- Complex system requiring structured breakdown

**Skip IF**:
- Single simple unit
- No decomposition needed
- Straightforward single-component implementation

**Execution**:
1. **MANDATORY**: Log any user input during this phase in branch audit file
2. Load all steps from `inception/units-generation.md`
3. Load reverse engineering artifacts (if brownfield)
4. Execute at appropriate depth (minimal/standard/comprehensive)
5. **Wait for Explicit Approval**: Present detailed completion message (see units-generation.md for message format) - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

---

# ðŸŸ¢ CONSTRUCTION PHASE

**Purpose**: Detailed design, NFR implementation, and code generation

**Focus**: Determine HOW to build it

**Stages in CONSTRUCTION PHASE**:
- Per-Unit Loop (executes for each unit):
  - Functional Design (CONDITIONAL, per-unit)
  - NFR Requirements (CONDITIONAL, per-unit)
  - NFR Design (CONDITIONAL, per-unit)
  - Infrastructure Design (CONDITIONAL, per-unit)
  - Code Generation (ALWAYS, per-unit)
- Build and Test (ALWAYS - after all units complete)

**Note**: Each unit is completed fully (design + code) before moving to the next unit.

---

## Per-Unit Loop (Executes for Each Unit)

**For each unit of work, execute the following stages in sequence:**

### Functional Design (CONDITIONAL, per-unit)

**Execute IF**:
- New data models or schemas
- Complex business logic
- Business rules need detailed design

**Skip IF**:
- Simple logic changes
- No new business logic

**Execution**:
1. **MANDATORY**: Log any user input during this stage in branch audit file
2. Load all steps from `construction/functional-design.md`
3. Execute functional design for this unit
4. **MANDATORY**: Present standardized 2-option completion message as defined in functional-design.md - DO NOT use emergent 3-option behavior
5. **Wait for Explicit Approval**: User must choose between "Request Changes" or "Continue to Next Stage" - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

### NFR Requirements (CONDITIONAL, per-unit)

**Execute IF**:
- Performance requirements exist
- Security considerations needed
- Scalability concerns present
- Tech stack selection required

**Skip IF**:
- No NFR requirements
- Tech stack already determined

**Execution**:
1. **MANDATORY**: Log any user input during this stage in branch audit file
2. Load all steps from `construction/nfr-requirements.md`
3. Execute NFR assessment for this unit
4. **MANDATORY**: Present standardized 2-option completion message as defined in nfr-requirements.md - DO NOT use emergent behavior
5. **Wait for Explicit Approval**: User must choose between "Request Changes" or "Continue to Next Stage" - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

### NFR Design (CONDITIONAL, per-unit)

**Execute IF**:
- NFR Requirements was executed
- NFR patterns need to be incorporated

**Skip IF**:
- No NFR requirements
- NFR Requirements Assessment was skipped

**Execution**:
1. **MANDATORY**: Log any user input during this stage in branch audit file
2. Load all steps from `construction/nfr-design.md`
3. Execute NFR design for this unit
4. **MANDATORY**: Present standardized 2-option completion message as defined in nfr-design.md - DO NOT use emergent behavior
5. **Wait for Explicit Approval**: User must choose between "Request Changes" or "Continue to Next Stage" - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

### Infrastructure Design (CONDITIONAL, per-unit)

**Execute IF**:
- Infrastructure services need mapping
- Deployment architecture required
- Cloud resources need specification

**Skip IF**:
- No infrastructure changes
- Infrastructure already defined

**Execution**:
1. **MANDATORY**: Log any user input during this stage in branch audit file
2. Load all steps from `construction/infrastructure-design.md`
3. Execute infrastructure design for this unit
4. **MANDATORY**: Present standardized 2-option completion message as defined in infrastructure-design.md - DO NOT use emergent behavior
5. **Wait for Explicit Approval**: User must choose between "Request Changes" or "Continue to Next Stage" - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

### Code Generation (ALWAYS EXECUTE, per-unit)

**Always executes for each unit**

**Code Generation has two parts within one stage**:
1. **Part 1 - Planning**: Create detailed code generation plan with explicit steps
2. **Part 2 - Generation**: Execute approved plan to generate code, tests, and artifacts

**Execution**:
1. **MANDATORY**: Log any user input during this stage in branch audit file
2. Load all steps from `construction/code-generation.md`
3. **PART 1 - Planning**: Create code generation plan with checkboxes, get user approval
4. **PART 2 - Generation**: Execute approved plan to generate code for this unit
5. **MANDATORY**: Present standardized 2-option completion message as defined in code-generation.md - DO NOT use emergent behavior
6. **Wait for Explicit Approval**: User must choose between "Request Changes" or "Continue to Next Stage" - DO NOT PROCEED until user confirms
7. **MANDATORY**: Log user's response in branch audit file with complete raw input

**Note**: CHANGELOG is updated via `/aidlc-changelog` command when user is ready.

---

## Build and Test (ALWAYS EXECUTE)

1. **MANDATORY**: Log any user input during this phase in branch audit file
2. Load all steps from `construction/build-and-test.md`
3. Generate comprehensive build and test instructions:
   - Build instructions for all units
   - Unit test execution instructions
   - Integration test instructions (test interactions between units)
   - Performance test instructions (if applicable)
   - Additional test instructions as needed (contract tests, security tests, e2e tests)
4. Create instruction files in build-and-test/ subdirectory: build-instructions.md, unit-test-instructions.md, integration-test-instructions.md, performance-test-instructions.md, build-and-test-summary.md
5. **Wait for Explicit Approval**: Ask: "**Build and test instructions complete. Ready to proceed to Operations stage?**" - DO NOT PROCEED until user confirms
6. **MANDATORY**: Log user's response in branch audit file with complete raw input

---

# ðŸŸ¡ OPERATIONS PHASE

**Purpose**: Placeholder for future deployment and monitoring workflows

**Focus**: How to DEPLOY and RUN it (future expansion)

**Stages in OPERATIONS PHASE**:
- Operations (PLACEHOLDER)

---

## Operations (PLACEHOLDER)

**Status**: This stage is currently a placeholder for future expansion.

The Operations stage will eventually include:
- Deployment planning and execution
- Monitoring and observability setup
- Incident response procedures
- Maintenance and support workflows
- Production readiness checklists

**Current State**: All build and test activities are handled in the CONSTRUCTION phase.

## Key Principles

- **Adaptive Execution**: Only execute stages that add value
- **Transparent Planning**: Always show execution plan before starting
- **User Control**: User can request stage inclusion/exclusion
- **Progress Tracking**: Update branch state file (`state/{branch}.md`) with executed and skipped stages
- **Complete Audit Trail**: Log ALL user inputs and AI responses in branch audit file with timestamps
  - **CRITICAL**: Capture user's COMPLETE RAW INPUT exactly as provided
  - **CRITICAL**: Never summarize or paraphrase user input in audit log
  - **CRITICAL**: Log every interaction, not just approvals
- **Quality Focus**: Complex changes get full treatment, simple changes stay efficient
- **Content Validation**: Always validate content before file creation per content-validation.md rules
- **Terminology Reference**: See `common/terminology.md` for glossary of AI-DLC terms (Phase vs Stage, Unit of Work, etc.)
- **Mermaid Diagrams Only**: ALL diagrams MUST use Mermaid syntax (see content-validation.md for details)
  - Architecture diagrams, workflow visualizations, sequence diagrams, class diagrams
  - NO ASCII art, NO external image files, NO third-party diagram tools
- **NO EMERGENT BEHAVIOR**: Construction phases MUST use standardized 2-option completion messages as defined in their respective rule files. DO NOT create 3-option menus or other emergent navigation patterns.
- **CHANGELOG**: User triggers `/aidlc-changelog` command to update CHANGELOG.md. Format: [Keep a Changelog](https://keepachangelog.com/en/1.1.0/)

## Mid-Workflow Change Handling

Users may request changes to the execution plan during the workflow. Handle these types of changes:

### Adding a Skipped Stage
1. Confirm request with user
2. Check prerequisites are complete
3. Update execution plan and state file
4. Execute the stage normally
5. Log change in audit file

### Skipping a Planned Stage
1. Confirm request and warn about impact
2. Get explicit confirmation
3. Mark stage as "SKIPPED" in state file
4. Note that later stages may require manual setup
5. Log change in audit file

### Restarting Current or Previous Stage
1. Understand user's concern and offer options (modify vs. restart)
2. If restart: Archive existing artifacts, reset checkboxes, re-execute
3. For previous stages: Warn about cascading impact on dependent stages
4. Log change in audit file

### Changing Depth Level
1. Confirm depth change (Minimal/Standard/Comprehensive)
2. Update execution plan
3. Follow new depth guidelines for remaining work
4. Log change in audit file

### Pausing Workflow
1. Complete current step if possible
2. Update all checkboxes and state file
3. Log pause point in audit file
4. On resume: Detect existing project and offer continuation options

**General Rules:**
- Always confirm before making destructive changes
- Archive existing work before making changes
- Update all tracking files (state, plan, audit) together
- Log all changes thoroughly for audit trail

## MANDATORY: Plan-Level Checkbox Enforcement

### MANDATORY RULES FOR PLAN EXECUTION
1. **NEVER complete any work without updating plan checkboxes**
2. **IMMEDIATELY after completing ANY step described in a plan file, mark that step [x]**
3. **This must happen in the SAME interaction where the work is completed**
4. **NO EXCEPTIONS**: Every plan step completion MUST be tracked with checkbox updates

### Two-Level Checkbox Tracking System
- **Plan-Level**: Track detailed execution progress within each stage
- **Stage-Level**: Track overall workflow progress in branch state file (`state/{branch}.md`)
- **Update immediately**: All progress updates in SAME interaction where work is completed

## Prompts Logging Requirements - Branch-Based Audit System

**IMPORTANT**: Load audit management rules from `common/audit-management.md` for full details.

### Branch-Based Audit Location
- **MANDATORY**: Determine current Git branch: `git branch --show-current`
- **MANDATORY**: Sanitize branch name (replace `/` with `-`, lowercase)
- **MANDATORY**: Use branch-specific audit file: `aidlc-docs/audit/{sanitized-branch}.md`
- **FALLBACK**: If no git or detached HEAD, use `main.md`

### Audit Directory Structure
```text
aidlc-docs/audit/
â”œâ”€â”€ audit-index.md              # Master index of all branches
â”œâ”€â”€ main.md                     # Main branch audit
â”œâ”€â”€ feature-{name}.md           # Feature branch audits
â”œâ”€â”€ bugfix-{name}.md            # Bugfix branch audits
â””â”€â”€ archived/                   # Merged branch audits
```

### Core Logging Requirements
- **MANDATORY**: Log EVERY user input (prompts, questions, responses) with timestamp
- **MANDATORY**: Capture user's COMPLETE RAW INPUT exactly as provided (never summarize)
- **MANDATORY**: Log every approval prompt with timestamp before asking the user
- **MANDATORY**: Record every user response with timestamp after receiving it
- **MANDATORY**: Include branch name in each audit entry
- **CRITICAL**: ALWAYS append changes, NEVER overwrite audit files
- Use ISO 8601 format for timestamps (YYYY-MM-DDTHH:MM:SSZ)
- Include stage context for each entry

### Audit Log Format:
```markdown
## [Stage Name or Interaction Type]
**Timestamp**: [ISO timestamp]
**Branch**: [current-git-branch]
**User Input**: "[Complete raw user input - never summarized]"
**AI Response**: "[AI's response or action taken]"
**Context**: [Stage, action, or decision made]

---
```

### On Session Start
1. Detect current Git branch
2. Check if `aidlc-docs/audit/{branch}.md` exists
3. If not exists, create with branch metadata header
4. Update `aidlc-docs/audit/audit-index.md` with branch entry

### Correct Tool Usage for Audit Files

âœ… CORRECT:

1. Read the branch audit file (e.g., `audit/feature-user-auth.md`)
2. Append/Edit the file to make changes

âŒ WRONG:

1. Read the audit file
2. Completely overwrite with contents plus new changes

## Directory Structure

```text
aidlc-docs/
â”œâ”€â”€ audit/                      # ðŸ“ Branch-based audit system
â”‚   â”œâ”€â”€ audit-index.md          # Master index of all branches
â”‚   â”œâ”€â”€ main.md                 # Main branch audit trail
â”‚   â”œâ”€â”€ feature-{name}.md       # Feature branch audits
â”‚   â”œâ”€â”€ bugfix-{name}.md        # Bugfix branch audits
â”‚   â””â”€â”€ archived/               # Merged/completed branch audits
â”‚       â””â”€â”€ {branch-name}.md
â”œâ”€â”€ state/                      # ðŸ“Š Branch-based state tracking
â”‚   â”œâ”€â”€ state-index.md          # Master index of all state files
â”‚   â”œâ”€â”€ main.md                 # State for main/master branch
â”‚   â”œâ”€â”€ {branch-name}.md        # State for each feature branch
â”‚   â””â”€â”€ archived/               # Merged/completed branch states
â”œâ”€â”€ branches/                   # ðŸ“ Branch-based artifacts (parallel work)
â”‚   â”œâ”€â”€ branches-index.md       # Master index of all branches
â”‚   â”œâ”€â”€ main/                   # Main branch artifacts
â”‚   â”‚   â”œâ”€â”€ inception/          # ðŸ”µ INCEPTION PHASE artifacts
â”‚   â”‚   â”‚   â”œâ”€â”€ plans/
â”‚   â”‚   â”‚   â”œâ”€â”€ reverse-engineering/  # Brownfield only
â”‚   â”‚   â”‚   â”œâ”€â”€ requirements/
â”‚   â”‚   â”‚   â”œâ”€â”€ user-stories/
â”‚   â”‚   â”‚   â””â”€â”€ application-design/
â”‚   â”‚   â””â”€â”€ construction/       # ðŸŸ¢ CONSTRUCTION PHASE artifacts
â”‚   â”‚       â”œâ”€â”€ plans/
â”‚   â”‚       â”œâ”€â”€ {unit-name}/
â”‚   â”‚       â””â”€â”€ build-and-test/
â”‚   â”œâ”€â”€ feature-{name}/         # Feature branch artifacts
â”‚   â”‚   â”œâ”€â”€ inception/
â”‚   â”‚   â””â”€â”€ construction/
â”‚   â””â”€â”€ archived/               # Merged/completed branch artifacts
â”‚       â””â”€â”€ {branch-name}/
â””â”€â”€ operations/                 # ðŸŸ¡ OPERATIONS PHASE artifacts (placeholder)
    â””â”€â”€ [Future: deployment and monitoring artifacts]
```

> **Note**: See `common/branch-artifacts.md` for detailed artifact paths and management rules.
